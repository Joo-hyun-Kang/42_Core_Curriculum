# 느낀점
## gnl에서는 운영체제 파일 시스템을 배움
## 자료구조에 대한 고민을 심하게 함 막상 구현은 어렵지 않았음
## 연결리스트를 쓰는 보너스 문제에서 왜 객체 지향이 생겼는지 감을 얻을 수 있었음

#  뭐하고 있는가?

#  get_next_line는 어떤 프로젝트인가?
* 파일에서 한줄까지 읽거나 한 줄이 없는 경우 그 파일의 끝까지 읽는 함수
* 사용자가 버퍼 사이즈(어느 정도 토막내서 불러올지)를 결정할 수 있다

## 이슈 : 자료구조 고민
* 고민의 흔적
* 1. 버퍼 크기 : 동적 할당 배열 vs 큐 
* 2. 버퍼 크기를 늘려야 할 때 어떻게: 1. 버퍼 크기 알고리즘에서 연결리스트 혹은 동적 할당 배열
* 3. 보너스 fd를 담을 공간 : 해시테이블 vs 연결리스트

<br>

* 유레카!!!!, 버퍼는 네트워크처럼 큐로 잡으면 됌. 그리고 이 크기는 1이든, 10000이든 상관이 없음
* 큐니까. 큐는 반환할 곳에 계속 데이터를 쏘면서 줄바꿈 or EOF까지 탐색함 그리고 오면 반환
* 줄바꿈이 왔는데 큐에 데이터가 남아 있으면 static이니까 노 상관
* 1. 버퍼 크기 큐로 => 동적 배열로 하면 크기를 늘리고 다시 memcpy함 바로 반환 쏴주는게
* 2. 버퍼크기를 늘려야 할 때 어떻게 => 반환 배열이기 때문에 동적할당해야 연결리스트 쓰면 반환이 일렬도 char *로 안되니까(c#의 리스트를 구현하자)
* 3. fd가 어느정도 들어올지 모르기 때문에 해시테이블이 더 성능이 좋지만 불확실성 때문에 연결리스트 씀

<br>

보너스 파트는 연결 리스트가 맞음 몇개의 파일을 열지 스크립트에서 제공되지 않았으니까    
실제 상용 API였다면 사용하다가 몇 개의 파일 fd를 사용하는 지 알게 되면 그 때 해시테이블을 이용해서 리펙토링 하는게 맞아보임.    
파일에서 큐 버퍼와 탐색 후 저장해두는 곳을 따로 두는 이유는 둘이 합칠 경우    
-파일에서 읽어오는 것 대비 너무 메모리 커지게 유지 될 수 있음    
-그리고 그걸 다음 읽어온 것 대비해서 다시 유동적으로 옮기는 건 불필요함    
-중간에 레이어를 두어서 큐는 계속 받아오고 메모리가 커지게 하는 기능은 따로 두어서 분리시켜서 기능을 한 개씩 독립적이게 가지게 할 것 => 메모리를 다시 크게 늘리거나 줄이는 것과 큐에서 기존 자료를 남겨두는 것이 서로 상충되는 기능이라서 할려면 기존 자료를 memcpy해서 복사해야 함 따라서 레이어를 두어서 기능을 서로 독립적    
-유레카!! 레이어를 두는 이유는 기능 2개가 서로 독립적이 아니라 종속적이어서 이 기능을 2개로 나누면 종속이 사라지고 독립적으로 처리 가능하다!    
    
## 왜 버퍼 사이즈를 외부에서 주게 했을까? 수정 필요
* 한 줄을 읽는 함수라면 일반적으로 한 줄이 100 글자 안에 있을 것 예상하기 때문에
* 버퍼 사이즈를 100정도로 잡으면 동적 할당 없이 해결할 수 있다
* 그런데 굳이 버퍼 사이즈를 제공해주는 이유는 추측컨데, 로직을 조금만 바꾸면 해당 문자나 텍스트로 끝나는
* 주소를 반환하는 함수로 바꿀 수 있다 즉, 100 줄에 1번 나오는 걸 예상하는게 아니라 어떤 문자를 텍스트 내에서
* 탐색 가능하다.
<br>
* 다른 이유는 fd를 여러개 받고 그걸 여러개 저장하기 위해서는 동적할당을 해야함으로 실행 중에 fd의 수가 변경됨으로
* 보너스를 구현하기 쉽게 하기 위해서 의무적인 것부터 버퍼사이즈를 강요하면서 정적 할당이 아닌 동적 할당으로 풀게 했다
* 그리고 정적으로 풀면 어렵지 않으니까?
<br>
* (짧은 소감) 상사가 시켰으면 왜 그랬을까 물어봤을텐데...

#  어떻게 구현했는가?

## 이슈: 파라미터 file descripter 예외처리 방법 : 테스트 ㄱㄱ
파일 디스크립트와 인덱스  
* 같은 파일을 한 프로세스에서 2번 열었을 때 process의 파일 테이블에 새로운 fd가 생성됨
* 그리고 각 fd마다 system 파일 테이블에 독자적인 파일 상태 플러그, 파일 offset, inode주소를 가짐
* 단, 가르키는 아이노드는 같음 말그대로 주소값은 그대로고 포인터 구조체 변수가 새로 생성된다고 할 수 있다
* 다른 프로세스도 마찬가지임
* https://ehpub.co.kr/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-3-5-%ED%8C%8C%EC%9D%BC-%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC-%ED%8C%8C%EC%9D%BC-%EB%94%94/
<br>
예외처리를 해야할까? 아니오
* gnl은 외부 사용자가 사용하는게 아니라 프로그래머가 사용할 함수
* 그리고 외부 시스템과 만나는데 파일 스크립터를 통해서 만남 그런데 이경우는 open을 통해서 만나게 됨, 혹은 기본적인 것 
* 예외처리는 open 함수에서 해야하지 gnl의 영역이 아님

## 이슈: 줄바꿈 다음에도 문자가 남아있어 그 문자를 계속 기억해두어아야 하는 경우 언제 free? : 아이디어는 얻음
* static 변수에 계속 저장해두되 줄바꿈이랑 일치할 때가 eof 때 프리한다
* 다만 이렇게 될 경우 gnl을 중간에 부르고 그냥 놔버리면 메모리 누수가 생긴다
* lseek()을 못 쓰고 read를 1번만 할 수 있는 제약이 있어서 그런데...
* 버퍼 사이즈가 일정한 경우에 정적 배열을 선언해서 남은 문자를 데이터 섹션에 남은 문자를 남겨둘 수 있는데
* 이게 더 메모리 누수가 없을 것 같다. 버퍼 사이즈 한 40정도해서 그러면 남는 문자도 40 이하니까 
* 데이터 섹션에 잡혀도 문제 없을 듯

## 이슈: 버퍼 사이즈로 잘라온 것에 줄바꿈이 없는 경우 널 반환해야 하는가? : 해결중...
* 버퍼 사이즈 < 줄바꿈 일때도 기존에 것을 기억했다가 나중에 줄바꿈이 나올 때까지 출력해야 함
* 그런데 1번 출력했을 때 널이 나오고 2번째 출력했을 때 제대로 이전 것 까지 나오게 구현
* 하지만 첫번째 것은 널을 반환해야 하나? 널을 반환하는 것이 아니라 줄바꿈이 나올 때까지 read
* 만약에 read 했는데도 불구하고 줄바꿈이 없으면 끝까지 읽는다
### 버퍼 사이즈를 얼만큼 잡아야 할까? 동적할당 많이 메모리 적게 vs 동적할당 적게 메모리 많이
* 일반적으로 줄바꿈이 100글자 안에 적어도 있을 것이라고 예상되고
* 사용자가 버퍼 사이즈를 잡는게 일반적으로 적게 1줄을 출력하는 함수이기 때문에 크게 잡지 않을 것
* 함수 시그니처에서 알려주는 것처럼
* 즉 사용자가 버퍼 사이즈를 작게 잡을 것이라고 예상 이럴 때는 동적 할당 적게, 메모리 많이가 맞음
* 버퍼 사이즈를 4배로 잡아서 동적할당을 최소한으로 적게할 것

* 따라서 버퍼 사이즈를 사용자가 입력하는 것에 4배로 잡을 것

### 버퍼 사이즈 중간에 줄바꿈이 있는 경우
* 남는 문자들을 스태틱에 저장한 상태로 둘 것

## 이슈: 왜 문자열 1개씩이 아니라 블록 단위로 접근할까
* 파일은 하드에 있고 하드에 접근하는 건 1바이트씩 접근하기에는 너무 느리다 매모리에 바로 올려져 있는 stdin과는 다르다

## 이슈: 보너스 문제를 어떻게 풀 것인가?
정적 변수 1개 사용

<br>
fd가 여러 개 들어오는 경우 보존

## 이슈: 버퍼 사이즈가 굉장히 크게 덩어리로 가져올 때 바로 리드 하는 것이 아니라 리드 한 것에 남겨두기: 해결
* 버퍼 사이즈 >= 줄바꿈
	* 리드 하고 나서 남은 줄들을 새로운 줄 이전에 받아와야 함

## 이슈: read 함수가 gnl 함수 호출 뒤에도 여전히 그 다음 것을 읽어주는 지 : 해결
* read는 별도로 이동시켜주지 않아도 읽은 그 다음을 읽는다
### read 함수는 왜 그런지?

## 이슈: 왜 마지막에 널문자를 붙여주는지? : 해결
텍스트 데이터로 들어오기 때문에 거기까지 탐색해서 반환하려고


## 한글을 읽게끔 구현은? : 해결 중...
POCU 아카데미 강의 참조해보기

# 왜? 
## read 함수 리턴 값
RETURN VALUES
     If successful, the number of bytes actually read is returned.  Upon reading end-of-file, zero is
     returned.  Otherwise, a -1 is returned and the global variable errno is set to indicate the error.

# 부가적인 지식
## 리눅스 출력 시 $는 줄바꿈 혹은 EOF, \n은 그냥 적는 건 특수문자가 아니라 텍스트일뿐
## 파일 시스템 콜
* 경로명을 따라가는 잃은 항상 파일 시스템의 루트에서 시작하며, 루트 디렉터리(root
directory)는 /로 표기된다. 파일 시스템이 디스크에서 가장 먼저 읽을 잃은 루트 디렉터리의 아이노드이다. 
루트 디౪터리의 아이노드는 어디에 있는가? 아이노드를 찾기위해서는 i-number를 알아야 한다.
일반적으로 어떤 파일이나 디౪터리의 i-number는
부모 디౪터리에서 찾을 수 있다. 루트는 부모가 ᨧ다 (정의상 ᨧ음). 루트 i-number는
“잘 알려진” 잃이어야 한다. 파일 시스템이 마운트될 때 이 값이 결정된다. 대부분의
Unix 파일 시스템에서는 루트 디౪터리의 아이노드 번호는 2번이다. 파일 시스템은
아이노드 번호 2번을 포함하는 블럭을 읽는다 (첫 번째 아이노드 블럭).
파일 시스템은 읽어들인 아이노드에서 데이터 블럭의 포인터를 추출한다. 포인터가
가리키는 블럭에는 루트 디౪터리의 내용이 들어 있다. 파일 시스템은 이 포인터들을
사용하여 디౪터리 정보를 읽고, foo라는 항목을 찾는다. 디౪터리에 많은 파일이
들어있을 수 있다. 예를 들어 3,000개. 이 경우, 모든 항목을 하나의 블럭에 저장할 수
ᨧ다. 하나의 디౪터리를 표현하기 위해 다수의 블럭이 사용된다. 하나 또는 그 이상의
디౪터리 데이터 블럭을 읽어서 foo에 대한 항목을 찾을 수 있다. foo 파일의 디౪터리
항목을 찾아서, foo의 아이노드 번호 (44라고 하자)를 파악한다. 우리는 이 아이노드
(44번 아이노드)가 필요하다.
다음 순서는 경로명을 따라가서 원하는 아이노드를 찾는다. 이 예제에서 파일 시스
템은 foo의 아이노드가 있는 블럭과 그에 대한 디౪터리 데이터를 읽은 후에 마침내
bar에 대한 아이노드 번호를 찾아낸다. 마지막 단계의 open()은 bar에 대한 아이노
드를 메모리로 읽어 들인다. 파일 시스템은 최종적으로 해당 파일에 대한 접근 권한을
확인하고, 이 프로세스의 open ile-table에서 파일 디스크립터를 할당받아 사용자에게
리턴한다.   
* 출처 : 운영체제 : 아주 쉬운 세 가지 이야기 [ch 40]   
## 파일 디스크립터와  open-file table
*지금까지는 위에서 다 설명했던 내용이다. 그 다음 과정에는 open-file table이라는 새로운 개념이 들어간다. open-file table은 open()함수에 의해 open된 파일의 list 형태로 나타낸 테이블이다. 즉 이 테이블에는 open된 파일이 모두 들어와 있다고 보면 된다.  
*open-file table은 결국 파일의 metadata가 저장되어 있는 주소값을 가지고 있는 것이고 그 각각의 index에 대한 주소가 바로 open()함수의 return 값이 되는 것이다. 이제 파일을 어떻게 access하는지 대략적으로 감을 잡았으리라고 본다. 그러면 이제는 조금 더 구체적으로 과정을 이야기 해보자. 방금전에 open-file table에 대해서 이야기를 했다.    
*그런데 이 open-file table은 사실 두 가지 형태로 존재한다. per-process open-file table 그리고 system-wide open-file table이다. per-process open-file table은 프로세스마다 가지고 있는 open-file table이다. system-wide open-file table은 시스템의 모든 open된 파일들에 대한 open-file table이다.    
* 출처: https://operatingsystems.tistory.com/entry/OS-File-System [Maybe]   
## window VS code 환경에서 파일 여러개 빌드하고 디버깅 하는 방법 
* wsl 설치, 우분투 설치
* gcc 설치 등을 위해서 업그레이드 https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=lidaxi043682&logNo=221717515827
* vs 코드 리눅스로 실행 후 launch 에서 분할 컴파일이 되게 *.c로 수정 https://www.youtube.com/watch?v=DVyYnOHP4nY&t=441s&ab_channel=MichaelHoefer
* lanch, task 생성 gcc, /bin에 있는 gcc-9로 설정
* 마지막으로 https://sjkim-dev.tistory.com/26 c_cpp_프로퍼티 만들어주기
* 디버그는 잘 되는데 C라이브러리 안에 탐색하는 디버그는 안 되고(소스코드 못 보고) 그냥 내 코드 f10으로 보는 건 된다.
