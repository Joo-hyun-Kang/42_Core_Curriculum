#  뭐하고 있는가?

## 이슈: 버퍼 사이즈로 잘라온 것에 줄바꿈이 없는 경우 널 반환해야 하는가? : 해결중...

#  get_next_line는 어떤 프로젝트인가?


#  어떻게 구현했는가?

## 이슈: 버퍼 사이즈로 잘라온 것에 줄바꿈이 없는 경우 널 반환해야 하는가? : 해결중...
* 버퍼 사이즈 < 줄바꿈 일때도 기존에 것을 기억했다가 나중에 줄바꿈이 나올 때까지 출력해야 함

## 이슈: 버퍼 사이즈가 굉장히 크게 덩어리로 가져올 때 바로 리드 하는 것이 아니라 리드 한 것에 남겨두기: 해결
* 버퍼 사이즈 >= 줄바꿈
	* 리드 하고 나서 남은 줄들을 새로운 줄 이전에 받아와야 함

## 이슈: read 함수가 gnl 함수 호출 뒤에도 여전히 그 다음 것을 읽어주는 지 : 해결
* read는 별도로 이동시켜주지 않아도 읽은 그 다음을 읽는다
### read 함수는 왜 그런지?

## 이슈: 왜 마지막에 널문자를 붙여주는지? : 해결
텍스트 데이터로 들어오기 때문에 거기까지 탐색해서 반환하려고


## 한글을 읽게끔 구현은?


# 왜? 
## read 함수 리턴 값
RETURN VALUES
     If successful, the number of bytes actually read is returned.  Upon reading end-of-file, zero is
     returned.  Otherwise, a -1 is returned and the global variable errno is set to indicate the error.

# 부가적인 지식
## 리눅스 출력 시 $는 줄바꿈 혹은 EOF, \n은 그냥 적는 건 특수문자가 아니라 텍스트일뿐
## 파일 시스템 콜
* 경로명을 따라가는 잃은 항상 파일 시스템의 루트에서 시작하며, 루트 디렉터리(root
directory)는 /로 표기된다. 파일 시스템이 디스크에서 가장 먼저 읽을 잃은 루트 디
౪터리의 아이노드이다. 루트 디౪터리의 아이노드는 어디에 있는가? 아이노드를 찾기
위해서는 i-number를 알아야 한다. 일반적으로 어떤 파일이나 디౪터리의 i-number는
부모 디౪터리에서 찾을 수 있다. 루트는 부모가 ᨧ다 (정의상 ᨧ음). 루트 i-number는
“잘 알려진” 잃이어야 한다. 파일 시스템이 마운트될 때 이 값이 결정된다. 대부분의
Unix 파일 시스템에서는 루트 디౪터리의 아이노드 번호는 2번이다. 파일 시스템은
아이노드 번호 2번을 포함하는 블럭을 읽는다 (첫 번째 아이노드 블럭).
파일 시스템은 읽어들인 아이노드에서 데이터 블럭의 포인터를 추출한다. 포인터가
가리키는 블럭에는 루트 디౪터리의 내용이 들어 있다. 파일 시스템은 이 포인터들을
사용하여 디౪터리 정보를 읽고, foo라는 항목을 찾는다. 디౪터리에 많은 파일이
들어있을 수 있다. 예를 들어 3,000개. 이 경우, 모든 항목을 하나의 블럭에 저장할 수
ᨧ다. 하나의 디౪터리를 표현하기 위해 다수의 블럭이 사용된다. 하나 또는 그 이상의
디౪터리 데이터 블럭을 읽어서 foo에 대한 항목을 찾을 수 있다. foo 파일의 디౪터리
항목을 찾아서, foo의 아이노드 번호 (44라고 하자)를 파악한다. 우리는 이 아이노드
(44번 아이노드)가 필요하다.
다음 순서는 경로명을 따라가서 원하는 아이노드를 찾는다. 이 예제에서 파일 시스
템은 foo의 아이노드가 있는 블럭과 그에 대한 디౪터리 데이터를 읽은 후에 마침내
bar에 대한 아이노드 번호를 찾아낸다. 마지막 단계의 open()은 bar에 대한 아이노
드를 메모리로 읽어 들인다. 파일 시스템은 최종적으로 해당 파일에 대한 접근 권한을
확인하고, 이 프로세스의 open ile-table에서 파일 디스크립터를 할당받아 사용자에게
리턴한다.
출처 : 운영체제 : 아주 쉬운 세 가지 이야기 [ch 40]
## 파일 디스크립터와  open-file table
*지금까지는 위에서 다 설명했던 내용이다. 그 다음 과정에는 open-file table이라는 새로운 개념이 들어간다. open-file table은 open()함수에 의해 open된 파일의 list 형태로 나타낸 테이블이다. 즉 이 테이블에는 open된 파일이 모두 들어와 있다고 보면 된다.
*open-file table은 결국 파일의 metadata가 저장되어 있는 주소값을 가지고 있는 것이고 그 각각의 index에 대한 주소가 바로 open()함수의 return 값이 되는 것이다. 이제 파일을 어떻게 access하는지 대략적으로 감을 잡았으리라고 본다. 그러면 이제는 조금 더 구체적으로 과정을 이야기 해보자. 방금전에 open-file table에 대해서 이야기를 했다. 
*그런데 이 open-file table은 사실 두 가지 형태로 존재한다. per-process open-file table 그리고 system-wide open-file table이다. per-process open-file table은 프로세스마다 가지고 있는 open-file table이다. system-wide open-file table은 시스템의 모든 open된 파일들에 대한 open-file table이다. 
* 출처: https://operatingsystems.tistory.com/entry/OS-File-System [Maybe]
